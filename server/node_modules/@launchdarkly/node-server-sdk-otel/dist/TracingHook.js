"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line max-classes-per-file
const api_1 = require("@opentelemetry/api");
const node_server_sdk_1 = require("@launchdarkly/node-server-sdk");
const FEATURE_FLAG_SCOPE = 'feature_flag';
const FEATURE_FLAG_KEY_ATTR = `${FEATURE_FLAG_SCOPE}.key`;
const FEATURE_FLAG_PROVIDER_ATTR = `${FEATURE_FLAG_SCOPE}.provider.name`;
const FEATURE_FLAG_CONTEXT_ID_ATTR = `${FEATURE_FLAG_SCOPE}.context.id`;
const FEATURE_FLAG_RESULT_ATTR = `${FEATURE_FLAG_SCOPE}.result`;
const FEATURE_FLAG_VALUE_ATTR = `${FEATURE_FLAG_RESULT_ATTR}.value`;
const FEATURE_FLAG_VARIATION_INDEX_ATTR = `${FEATURE_FLAG_RESULT_ATTR}.variationIndex`;
const FEATURE_FLAG_REASON_ATTR = `${FEATURE_FLAG_RESULT_ATTR}.reason`;
const FEATURE_FLAG_IN_EXPERIMENT_ATTR = `${FEATURE_FLAG_REASON_ATTR}.inExperiment`;
const FEATURE_FLAG_SET_ID = `${FEATURE_FLAG_SCOPE}.set.id`;
const TRACING_HOOK_NAME = 'LaunchDarkly Tracing Hook';
const defaultOptions = {
    spans: false,
    includeValue: false,
    logger: (0, node_server_sdk_1.basicLogger)({ name: TRACING_HOOK_NAME }),
    environmentId: undefined,
};
function validateOptions(options) {
    const validatedOptions = Object.assign({}, defaultOptions);
    if ((options === null || options === void 0 ? void 0 : options.logger) !== undefined) {
        validatedOptions.logger = new node_server_sdk_1.SafeLogger(options.logger, defaultOptions.logger);
    }
    if ((options === null || options === void 0 ? void 0 : options.includeValue) !== undefined) {
        if (node_server_sdk_1.TypeValidators.Boolean.is(options.includeValue)) {
            validatedOptions.includeValue = options.includeValue;
        }
        else {
            validatedOptions.logger.error(node_server_sdk_1.OptionMessages.wrongOptionType('includeValue', 'boolean', typeof (options === null || options === void 0 ? void 0 : options.includeValue)));
        }
    }
    else if ((options === null || options === void 0 ? void 0 : options.includeVariant) !== undefined) {
        if (node_server_sdk_1.TypeValidators.Boolean.is(options.includeVariant)) {
            validatedOptions.includeValue = options.includeVariant;
        }
        else {
            validatedOptions.logger.error(node_server_sdk_1.OptionMessages.wrongOptionType('includeVariant', 'boolean', typeof (options === null || options === void 0 ? void 0 : options.includeVariant)));
        }
    }
    if ((options === null || options === void 0 ? void 0 : options.spans) !== undefined) {
        if (node_server_sdk_1.TypeValidators.Boolean.is(options.spans)) {
            validatedOptions.spans = options.spans;
        }
        else {
            validatedOptions.logger.error(node_server_sdk_1.OptionMessages.wrongOptionType('spans', 'boolean', typeof (options === null || options === void 0 ? void 0 : options.spans)));
        }
    }
    if ((options === null || options === void 0 ? void 0 : options.environmentId) !== undefined) {
        if (node_server_sdk_1.TypeValidators.String.is(options.environmentId)) {
            validatedOptions.environmentId = options.environmentId;
        }
        else {
            validatedOptions.logger.error(node_server_sdk_1.OptionMessages.wrongOptionType('environmentId', 'string', typeof (options === null || options === void 0 ? void 0 : options.environmentId)));
        }
    }
    return validatedOptions;
}
/**
 * The TracingHook adds OpenTelemetry support to the LaunchDarkly SDK.
 *
 * By default, span events will be added for each call to a "Variation" method.
 *
 * The span event will include the canonicalKey of the context, the provider of the evaluation
 * (LaunchDarkly), and the key of the flag being evaluated.
 */
class TracingHook {
    /**
     * Construct a TracingHook with the given options.
     *
     * @param options Options to customize tracing behavior.
     */
    constructor(options) {
        this._tracer = api_1.trace.getTracer('launchdarkly-client');
        this._options = validateOptions(options);
    }
    /**
     * Get the meta-data for the tracing hook.
     */
    getMetadata() {
        return {
            name: TRACING_HOOK_NAME,
        };
    }
    /**
     * Implements the "beforeEvaluation" stage of the TracingHook.
     */
    beforeEvaluation(hookContext, data) {
        if (this._options.spans) {
            const { canonicalKey } = node_server_sdk_1.Context.fromLDContext(hookContext.context);
            const span = this._tracer.startSpan(hookContext.method, undefined, api_1.context.active());
            span.setAttribute(FEATURE_FLAG_CONTEXT_ID_ATTR, canonicalKey);
            span.setAttribute(FEATURE_FLAG_KEY_ATTR, hookContext.flagKey);
            return Object.assign(Object.assign({}, data), { span });
        }
        return data;
    }
    /**
     * Implements the "afterEvaluation" stage of the TracingHook.
     */
    afterEvaluation(hookContext, data, detail) {
        var _a;
        (_a = data.span) === null || _a === void 0 ? void 0 : _a.end();
        const currentTrace = api_1.trace.getActiveSpan();
        if (currentTrace) {
            const eventAttributes = {
                [FEATURE_FLAG_KEY_ATTR]: hookContext.flagKey,
                [FEATURE_FLAG_PROVIDER_ATTR]: 'LaunchDarkly',
                [FEATURE_FLAG_CONTEXT_ID_ATTR]: node_server_sdk_1.Context.fromLDContext(hookContext.context).canonicalKey,
            };
            if (typeof detail.variationIndex === 'number') {
                eventAttributes[FEATURE_FLAG_VARIATION_INDEX_ATTR] = detail.variationIndex;
            }
            if (detail.reason.inExperiment) {
                eventAttributes[FEATURE_FLAG_IN_EXPERIMENT_ATTR] = detail.reason.inExperiment;
            }
            if (this._options.environmentId) {
                eventAttributes[FEATURE_FLAG_SET_ID] = this._options.environmentId;
            }
            else if (hookContext.environmentId) {
                eventAttributes[FEATURE_FLAG_SET_ID] = hookContext.environmentId;
            }
            if (this._options.includeValue) {
                eventAttributes[FEATURE_FLAG_VALUE_ATTR] = JSON.stringify(detail.value);
            }
            currentTrace.addEvent(FEATURE_FLAG_SCOPE, eventAttributes);
        }
        return data;
    }
}
exports.default = TracingHook;
//# sourceMappingURL=TracingHook.js.map